classdef ContinuousBgndAudioPlayer < AudioPlayer
%CONTINUOUSBGNDAUDIOPLAYER playes stimuli in continuous background sound.
%   The background (masker) sound comes from a SampleSource object.
%   Sound samples for AudioObject classes will be generated by 
%   appropriated AudioObjectSampleFactories. These have to be put into a
%   containers.Map with the AudioObject class name as key.
%   Optionally, a BinCodeGenerator can be specified that sends binary codes
%   to a trigger channel, synchronized with AudioObject onset. In that
%   case, the trigger channel must be the last index in channelMapping.

% Author: Lasse Osterhagen

properties
    % Source of background sound samples
    sampleSource
    % A containers.Map object that maps AudioObject class names (string)
    % to AudioObjectSampleFactories
    audioObjSamFacMap
    % Generator for binary code to be sent to the trigger channel
    % [default = no BinCodeGenerator]
    binCodeGenerator
    % Index of the trigger channel 
end

properties (Dependent, Access = private)
    % The audio stream will be updated with one chunk of samples
    % Number of samples in one chunk
    numChunkSamples
    % Sample size of the audio buffer
    numBufferSamples
    % Rate at witch the audio stream will be updated
    updatePeriod
end

properties (Access = private)
    % Size of a chunk of audio samples in s
    chunkSize = 0.05;
    % Timer that actualizes the sound stream
    updateTimer = timer.empty
    % 1-element buffer of the next AudioObject to play
    memAudioObject = [];
    % A cell array that contains sample arrays of chunkSize that
    % must be played next
    memBuffer = cell.empty;
end

methods

    function value = get.numChunkSamples(this)
        value = floor(this.chunkSize*this.sF);
    end

    function value = get.numBufferSamples(this)
        value = 2*floor(this.chunkSize*this.sF);
    end

    function value = get.updatePeriod(this)
        value = this.chunkSize*0.9;
        % chunkSize*0.9 is an empircally determined parameter
        % for the update periode of the sound buffer.
    end

    function this = ContinuousBgndAudioPlayer(config)
        % ContinuousBgndAudioPlayer(config)
        % Arguments:
        % config - a configuration struct with all parameters as
        %   fieldnames (including: sampleSource, audioObjSamFacMap,
        %   binCodeGenerator)
        this = this@AudioPlayer(config);
        this.sampleSource = config.sampleSource;
        this.audioObjSamFacMap = config.audioObjSamFacMap;
        this.binCodeGenerator = config.binCodeGenerator;
        this.updateTimer = timer('ExecutionMode', 'fixedSpacing', ...
            'Period', this.updatePeriod, ...
            'TimerFcn', @this.updateStream);
    end

    function delete(this)
        this.stop;
        delete(this.updateTimer);
    end

    function stop(this)
        % Stop playing sound.
        stop(this.updateTimer);
        PsychPortAudio('Stop', this.pahandle);
    end

    function start(this)
        % Start playing (background sound)
        audioData = zeros(this.numChannels, this.numBufferSamples);
        audioData(1,:) = this.sampleSource.getSamples( ...
            this.numBufferSamples);
        this.fillBuffer(audioData, 0);   
        PsychPortAudio('Start', this.pahandle, 0, 0, 1);
        start(this.updateTimer);
    end

    function playAudioObject(this, audioObject)
        this.memAudioObject = audioObject;
    end

end       

methods (Access = private)

    function startTime = fillBuffer(this, audioData, streamingRefill)
        % Fill the audio device's buffer with audioData.
        % streamingRefill is the same as documented at
        % https://docs.psychtoolbox.org/FillBuffer - first call should
        % be False, all following calls True.
        [~,~, startTime] = PsychPortAudio('FillBuffer', ...
            this.pahandle, audioData, streamingRefill);
    end

    function updateStream(this, ~, ~)
        % This callback function is periodically called by the
        % updateTimer to append new samples to the audio stream.
        % Attention: This function will lock Matlab if it is ahead
        % of the audio stream. That means it will synchonize
        % automatically with the audio stream but at the same time
        % leads to worse timing.
        if ~isempty(this.memBuffer)
            audioData = this.memBuffer{1};
            this.memBuffer(1) = [];
            this.fillBuffer(audioData, 1);
        elseif isempty(this.memAudioObject)
            audioData = zeros(this.numChannels, this.numChunkSamples);
            audioData(1,:) = this.sampleSource.getSamples( ...
                this.numChunkSamples);
            this.fillBuffer(audioData, 1);
        else
            audioObject = this.memAudioObject;
            this.memAudioObject = [];
            % Create AudioObject samples and fill the sound buffer with them.
            % If the AudioObject requires more samples than numChunkSamples,
            % insert the remaining samples into memBuffer.
            chunkSamples = this.numChunkSamples;
            % Determine the proper StimulusSampleFactory
            audioObjClass = class(audioObject);
            if ~isKey(this.audioObjSamFacMap, audioObjClass)
                error(['No AudioObjectSampleFactory defined for ', ...
                    'AudioObject of type ', audioObjClass, '.']);
            end
            audioObjSamFac = this.audioObjSamFacMap(audioObjClass);
            % Number of audio samples needed to represent audioObject
            numAudioSamples = audioObjSamFac.calcRequiredSamples( ...
                audioObject);

            % Create bin code if BinCodeGenerator available
            binCodeLength = 0;
            if ~isempty(this.binCodeGenerator)
                % Create binary code for trigger channel
                binCode = ...
                    this.binCodeGenerator.createCode(num2str(audioObject.id));
                binCodeLength = length(binCode);
            end

            neededSamples = max([numAudioSamples, binCodeLength, chunkSamples]);
            numChunks = ceil(neededSamples/chunkSamples);
            % Get enough raw audio samples to fill all chunks
            audioDataLength = numChunks*chunkSamples;
            rawAudioSamples = this.sampleSource.getSamples(audioDataLength);
            % Process the samples with the proper StimulusSampleFactory
            processedAudioData = audioObjSamFac.makeAudioObjectSamples( ...
                audioObject, rawAudioSamples);
            audioData = zeros(this.numChannels, audioDataLength);
            audioData(1:size(processedAudioData,1),:) = processedAudioData;
            if binCodeLength > 0
                audioData(end,1:binCodeLength) = binCode;
            end
            % Fill the next buffer with the first chunk of samples
            playData = audioData(:,1:chunkSamples);
            % Insert remaining samples into memBuffer
            for index=2:numChunks
                this.memBuffer{end+1} = ...
                    audioData(:,(index-1)*chunkSamples+1:index*chunkSamples);
            end
            this.lastAOTime = this.fillBuffer(playData, 1);        
        end
    end

end

end

